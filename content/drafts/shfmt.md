---
title: Mantenha a consist√™ncia na formata√ß√£o do seu c√≥digo com shfmt
description: >
  Al√©m de manter o seu c√≥digo com uma formata√ß√£o consistente, o shfmt tamb√©m pode tornar aquele c√≥digo obscuro que voc√™ achou por a√≠ em algo mais leg√≠vel.
tags:
  - boas-praticas
  - ferramentas
date: 2022-05-12T15:14:44-03:00
cover:
  image: "img/shfmt.png"
  alt: shfmt
draft: true
---

Neste artigo vamos conhecer o `shfmt`, uma ferramenta que vai te ajudar a manter seu c√≥digo com uma formata√ß√£o consistente, e tamb√©m para tornar leg√≠vel algum c√≥digo de outra pessoa que voc√™ queira examinar.

Veremos aqui o que √© e como instalar o `shfmt`, alguns exemplos de uso e como configurar o seu editor (VSCode e vim) para formatar seu c√≥digo assim que voc√™ salvar.

## Demonstra√ß√£o

S√≥ pra deixar claro, quando eu digo formata√ß√£o estou me referindo √† indenta√ß√£o, declara√ß√£o de fun√ß√µes, quebra de linhas de comandos longos... Enfim, coisas extremamente b√°sicas mas que influenciam bastante na legibilidade do seu c√≥digo.

Veja esse exemplo ilustrativo:
```bash
#!/bin/bash


 echo   'linha com formata√ß√£o ruim'
   echo 'outra linha com indenta√ß√£o feiosa'


echo 'voc√™ pode n√£o estar vendo...'
echo 'mas esta linha tem espa√ßos em branco no final > '            

func(){ if [[ $# -eq 0 ]];then echo "sem argumentos">&2;return 1;fi; echo "Hello, $1"; }

main() {
  echo 'mais espa√ßos desnecess√°rios'
              echo 'indenta√ß√£o exagerada'
 }

main       "$@"
```

Com `shfmt` conseguimos converter aquilo üëÜ, nisso aqui üëá

```bash
#!/bin/bash

echo 'linha com formata√ß√£o ruim'
echo 'outra linha com indenta√ß√£o feiosa'

echo 'voc√™ pode n√£o estar vendo...'
echo 'mas esta linha tem espa√ßos em branco no final > '

transfer() {
  if [[ $# -eq 0 ]]; then
    echo "sem argumentos" >&2
    return 1
  fi
  echo "Hello, $1"
}

main() {
  echo 'mais espa√ßos desnecess√°rios'
  echo 'indenta√ß√£o exagerada'
}

main "$@"
```


## Contexto pessoal

Desde que conheci o `shfmt` eu o uso para manter o meu pr√≥prio c√≥digo com uma formata√ß√£o consistente e alinhada com o meu *coding style*. Mas aonde ele me deixa mais feliz √© quando preciso trabalhar num c√≥digo originalmente escrito por uma pessoa sem experi√™ncia com programa√ß√£o shell.

Sabe como √© n√©... O shell √© uma linguagem muito poderosa e permissiva. A barreira de entrada √© bem pequena e devido ao poder do shell voc√™ consegue rapidamente resolver o que voc√™ precisa resolver. Por um lado isso √© bom (afinal, resolver problemas √© uma coisa boa!), mas em contrapartida acaba gerando muito c√≥digo bagun√ßado. Dif√≠cil de ler e de manter.

Pra agravar o cen√°rio, geralmente quem escreve shell scripts, s√£o SysAdmins. Historicamente um SysAdmin √© uma pessoa treinada para manter o sistema est√°vel, bem configurado e seguro. Focar em aprender t√©cnicas avan√ßadas de programa√ß√£o, *Clean Code*, e coisas do g√™nero normalmente n√£o √© uma prioridade para um SysAdmin.

Como resultado, √© bastante comum encontrar por a√≠ c√≥digo bem dif√≠cil de ler/analisar/atualizar/refatorar.

Quando me deparo com um cen√°rio desses, a primeir√≠ssima coisa que fa√ßo √© rodar o `shfmt` pra tornar o c√≥digo minimamente leg√≠vel (e na sequ√™ncia eu rodo [shellcheck](/shellcheck)).


## Instala√ß√£o

No [README do projeto](https://github.com/mvdan/sh) n√£o existe uma instru√ß√£o muito clara de como instalar o `shfmt`. Mas n√≥s vamos resolver isso bem r√°pido...

Se voc√™ usa uma distro baseada em Debian/Ubuntu, verifique se o programa est√° dispon√≠vel para voc√™ com `sudo apt install shfmt`.

Se sua distro possui Snap, voc√™ pode instalar com `snap install shfmt`.

Uma outra maneira √© simplesmente baixar o bin√°rio na [p√°gina de releases do projeto](https://github.com/mvdan/sh/releases).

Eu particularmente gosto de instalar essas ferramentinhas que tem um desenvolvimento bem ativo, usando o [asdf-vm](https://asdf-vm.com), pois assim consigo facilmente experimentar vers√µes mais atuais das ferramentas sem ficar instalando-as globalmente no meu sistema.

N√£o est√° no escopo desse artigo falar muito sobre o asdf-vm (fica pra um artigo futuro), mas se voc√™ tem ele a√≠, aqui est√° a receitinha de bolo pra instalar o `shfmt`:

```bash
# disponibilizando o shfmt para ser instalado via asdf
asdf plugin add shfmt

# instalando a vers√£o mais recente
asdf install shfmt latest

# definindo a vers√£o que ser√° disponibilizada no PATH
asdf global shfmt latest

# conferindo qual foi a vers√£o instalada
shfmt --version
```

> Observa√ß√£o: no momento da escrita desse artigo a vers√£o atual do shfmt √© 3.5.0


## Op√ß√µes de formata√ß√£o

A primeira op√ß√£o que eu gostaria de mostrar, √© o `-d`/`--diff`. Simplesmente por ser uma op√ß√£o onde a gente consegue ver um "diff" entre o nosso c√≥digo original e o resultado ap√≥s passar pelo `shfmt`. Isso vai te mostrar claramente o que mudou.

Vejamos com esse codiguinho aqui:
```bash
#!/bin/bash
hello() {
echo "Hello, $1"
}
hello    "$@"
```

Se a gente rodar o `shfmt -d hello.sh`, obteremos o seguinte diff (obs.: o arquivo original **N√ÉO** ser√° alterado):
```diff
--- hello.sh.orig
+++ hello.sh
@@ -1,6 +1,6 @@
 #!/bin/bash
 hello() {
-echo "Hello, $1"
+        echo "Hello, $1"
 }
 
-hello    "$@"
+hello "$@"
```

Podemos observar que o shfmt colocou uma indenta√ß√£o no `echo` dentro da fun√ß√£o `hello`, e tamb√©m tirou os espa√ßos desnecess√°rios na chamada da fun√ß√£o.

A formata√ß√£o default ficou bacaninha, n√©? Mas vamos ver como customizar para um estilo que mais nos agrade.

Por exemplo, eu n√£o curti muito aquela indenta√ß√£o com tab. Nos meus projetos eu costumo utilizar 2 espa√ßos para indenta√ß√£o.

Para isso vamos utilizar a op√ß√£o `-i`/`--indent` (junto com o `-d` pra vermos o diff)
```bash
shfmt -d -i 2 hello.sh
```

No diff, a gente vai observar o seguinte:
```diff
--- hello.sh.orig
+++ hello.sh
@@ -1,6 +1,6 @@
 #!/bin/bash
 hello() {
-echo "Hello, $1"
+  echo "Hello, $1"
 }
 
-hello    "$@"
+hello "$@"
```

Ah... Agora sim! Indenta√ß√£o com 2 espa√ßos. üôÇ

N√£o vou ficar demonstrando aqui o que cada op√ß√£o faz (afinal, eu te mostrei o macetinho do `--diff` exatamente para voc√™ fazer suas experimenta√ß√µes a√≠). Mas vou listar aqui as op√ß√µes que eu costumo usar:

- `-bn`, `--binary-next-line`: para que os operadores bin√°rios `&&`, `||` e at√© o `|` sejam colocados no come√ßo da pr√≥xima linha.
```bash
# antes do 'shfmt -bn'
comando1 && 
  comando2 &&
  comando3

# depois do 'shfmt -bn'
comando1 \
  && comando2
  && comando3
```

- `-ci`, `--ci-indent`: para adicionar indenta√ß√£o em cada op√ß√£o dentro de um `case`.
```bash
# antes do 'shfmt -ci'
case "${extension}" in
.txt)
  echo "texto"
  ;;
.mp3)
  echo "m√∫sica"
  ;;
.md)
  echo "markdown"
  ;;
*)
  echo "outro formato"
  ;;
esac

# depois do 'shfmt -ci'
case "${extension}" in
  .txt)
    echo "texto"
    ;;
  .mp3)
    echo "m√∫sica"
    ;;
  .md)
    echo "markdown"
    ;;
  *)
    echo "outro formato"
    ;;
esac
```

- `-sr`, `--space-redirects`: operadores de redirecionamento ser√£o seguidos por um espa√ßo.
```bash
# antes do 'shfmt -sr'
grep meleu /etc/passwd >myInfo.txt

# depois do 'shfmt -sr'
grep meleu /etc/passwd > myInfo.txt
```

As outras op√ß√µes de formata√ß√£o eu n√£o costumo usar, mas recomendo que voc√™ experimente um pouco e veja se faz sentido pra voc√™.

## Pontos de aten√ß√£o!

Apesar de ser uma ferramenta extremamente √∫til, existem alguns casos onde precisamos ficar atento pois o `shfmt` n√£o √© capaz de lidar.

Isso est√° listado no [README do projeto](https://github.com/mvdan/sh#caveats) e n√≥s vamos dar uma analisada aqui.

### √çndices de arrays associativos precisam de aspas

Quando estiver usando um array associativo, o `shfmt` vai precisar que voc√™ coloque os √≠ndices entre aspas. Caso contr√°rio ele ter√° problemas para formatar √≠ndices com espa√ßos ou sinais aritm√©ticos.

Imagine um array desse tipo aqui:
```bash
$ # para o bash isso aqui √© perfeitamente v√°lido
$ declare -A array=([indice-1]=um [indice-2]=dois)

$ # passando esse c√≥digo para o shfmt
$ echo 'declare -A array=([indice-1]=um [indice-2]=dois)' \
  | shfmt
declare -A array=([indice - 1]=um [indice - 2]=dois)
$ # espa√ßos indevidos aqui üëÜ    e aqui  üëÜ
```

O problema √© que o parser do `shfmt` acredita que ali dentro daqueles `[colchetes]` tem uma express√£o aritm√©tica, e a√≠ tenta formatar essa express√£o pra ficar bonitinha.

Inclusive, se o nosso √≠ndice tiver espa√ßos, o shfmt vai reclamar que n√£o estamos passando uma express√£o v√°lida:
```bash
$ # express√£o v√°lida no bash
$ declare -A array=([indice 1]=um)

$ # mas inv√°lida para o shfmt
$ echo 'declare -A array=([indice 1]=um)' | shfmt
<standard input>:1:27: not a valid arithmetic operator: 1
```

**Solu√ß√£o**: basta usarmos aspas que o parser do `shfmt` vai saber que estamos passando uma string (e n√£o uma express√£o aritm√©tica):
```bash
$ echo 'declare -A array=(["indice 1"]=um ["indice-2"]=dois)' \
  | shfmt
declare -A array=(["indice 1"]=um ["indice-2"]=dois)

```


### Ambiguidade entre `$((` e `((`

Recapitulando aqui 3 *features* do bash:

1. `$((express√£o))`: executa uma express√£o aritm√©tica.
    - ex.: `echo "Voc√™ nasceu em $((thisYear - age))"`
2. `$(comando)`: executa o `comando` e devolve o output daquele comando.
    - ex.: `echo "Voc√™ est√° no diret√≥rio $(pwd)"`
3. `(comando)`: executa um `comando` em subshell.
    - ex.: `(cd /tmp; rm -f files*)`

Se combinarmos a t√©cnica do item 2 com a do item 3, podemos ter uma situa√ß√£o do tipo
```bash
# isso √© perfeitamente v√°lido em bash
echo "output dos comandos: $((comando1); (comando2))"
# o shfmt vai confundir isso üëÜ
```

Como podemos notar, aquele comecinho ali com `$((` vai confundir o `shfmt`.
```txt
$ echo '$((comando1); (comando2))' | shfmt
<standard input>:1:1: reached ) without matching $(( with ))
```

De fato, essa nota√ß√£o √© apontada no pr√≥prio [padr√£o POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_03) como uma nota√ß√£o amb√≠gua. E recomenda que seja usado um espa√ßo para separar o `$(` e o `(`.

```txt
$ # com espa√ßos, fica deboas üëç
$ echo '$( (comando1); (comando2) )' | shfmt -i 2
$(
  (comando1)
  (comando2)
)

```


### Declara√ß√µes "ex√≥ticas" n√£o s√£o suportadas

Em bash voc√™ consegue declarar duas vari√°veis e atribuir o mesmo valor a ambas em uma √∫nica linha, usando essa nota√ß√£o aqui:
```bash
declare {var1,var2}=valor
```

Essa nota√ß√£o n√£o √© suportada pelo `shfmt`, pois ele vai achar que voc√™ est√° querendo declarar uma vari√°vel chamada `{var1,var2}`:
```txt
$ echo 'declare {var1,var2}=valor' | shfmt
<standard input>:1:9: invalid var name
```

No meu caso isso n√£o se torna exatamente um problema, pois eu n√£o uso nem jamais usaria tal nota√ß√£o (pois acredito que o c√≥digo deve ser o mais claro e expl√≠cito poss√≠vel).


### A op√ß√£o `--binary-next-line` n√£o se aplica a `[[ testes ]]`

Todos os "probleminhas" listados acima s√£o perfeitamente aceit√°veis pra mim. Tenho pra mim que eles at√© encorajam boas pr√°ticas.

Mas esse aqui √© o √∫nico "probleminha" do `shfmt` que me incomoda (mas nem por isso parei de us√°-lo em TODOS os meus scripts).

Esse problema n√£o est√° na [lista de *caveats* do README](https://github.com/mvdan/sh#caveats), mas existe [uma issue aberta sobre isso](https://github.com/mvdan/sh/issues/813).

O lance √© que a op√ß√£o `-bn`,`--binary-next-line` n√£o se aplica √†s express√µes dentro dos `[[ colchetes ]]`.



Express√µes longas como essa n√£o s√£o muito comuns nos meus c√≥digos, mas de vez em quando aparecem.










## Formatando um c√≥digo "confuso"

aplicar nesse script aqui do transfer.sh
```bash
transfer(){ if [ $# -eq 0 ];then echo "No arguments specified.\nUsage:\n transfer <file|directory>\n ... | transfer <file_name>">&2;return 1;fi;if tty -s;then file="$1";file_name=$(basename "$file");if [ ! -e "$file" ];then echo "$file: No such file or directory">&2;return 1;fi;if [ -d "$file" ];then file_name="$file_name.zip" ,;(cd "$file"&&zip -r -q - .)|curl --progress-bar --upload-file "-" "https://transfer.sh/$file_name"|tee /dev/null,;else cat "$file"|curl --progress-bar --upload-file "-" "https://transfer.sh/$file_name"|tee /dev/null;fi;else file_name=$1;curl --progress-bar --upload-file "-" "https://transfer.sh/$file_name"|tee /dev/null;fi;}
```



## Instale shfmt no seu editor

### VSCode

### vim

### b√¥nus: EditorConfig


